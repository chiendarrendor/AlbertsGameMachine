Overview: 

  This document describes the API for generating a DLL capable of
adjucating a game within Albert's Game Machine framework.  The
structure of a game adjucator is encoded in an XML document (syntax
described below) which represents a finite state machine, consisting
of states, and transitions between them.  The XML for the transitions
consists of small snippets of C++ code that are built into the proper
structure by the transition compiler 'tcom.pl'.

   These snippets of code require a pair of user-provided C++ classes
to be compiled with the C++ code generated by the transition compiler.
Given a game name such as "Foo" (see below for designation of a game
name), the two required classes are "FooSet", which is instanciated
once when a given DLL is first loaded and should contain information
that all running games of that type can share, such as map
connectivity, and "FooState", which is a boost-xml-serializable class,
constructed with a FooState object, that contains all information
about the living state of a game.

     The transitions represent a response to either user input, in the
form of incoming messages called "actions", or an automatic response
to certain user-defined data being detected, deemed "auto"
transitions.  A transition is responsible for generating all outgoing
messages, or "events", that are necessary for reporting to
users/players how the state of the game has changed given the
transitions.

     Another section of the XML is the "refresh" section, which
contains another snippet of C++ that is called whenever a player needs
to refresh the entire state of the game, and should generate any and
all events to that player only representing the entire state of the
game.

Finally, there is a section called 'preface', which contains any additional
includes or utility functions/classes that the snippet code may use.


Server XML Documentation:

Note on code snippets:
all code snippets described below, with the exception of 'preface', are turned
into public methods in an object called <GameName>GameInfo, as are all the
methods created by 'event' nodes in the XML document.  Preface, on the other
hand, is added verbatim to the top of the <GameName>DLL.cpp file, which
contains the bodies themselves of these selfsame methods.

<GameName>GameInfo is a public subclass of <GameName>State, the
required user-defined game state class, so that any public or
protected method or attribute of <GameName>State is directly available
to the code snippets, as are all the messaging methods created by 'event'
nodes.

All states are represented by a public member constant within the GameInfo
object with the same name as the state, so that the coder can write 

if (i_StateName == ValidateSetup)

instead of 

if (i_StateName == "ValidateSetup")



Root Node "game":
     <game>
     </game>

     Attributes:
	Required: name="GameName" -- name must follow valid C++ type name syntax
	Optional: autorecursiondepth="20" -- number of 'auto' steps 
		before returning control to players

     Child nodes:
	   <state></state> -- description of a state in state machine
	   <transition></transition> -- description of a state transition
	   <event></event> -- description of an event (outgoing messages)
	   <refresh></refresh> -- code for entire state refresh
	   <preface></preface> -- (optional) headers and other code

"state" node
     <state />
     
     Attributes:
	Required: name="name" -- name of state must follow valid C++ type name syntax
	Required: desc="desc" -- human readable description of state

     -- The game always provides two states that do not have to be specified 
	InitialState -- a new game always starts in this state
	TerminalState 
		      -- a game is deemed to be over when in this state.
		      -- no transitions are allowed from this state.

"preface" node
    <preface>
    </preface>

    Attributes: none
    Child Nodes: none

    the contents of the preface node are placed at the top of the .cpp file
    containing all the snippets of C++ code in the XML.  It is not necessary
    to use this to #include <GameName>State.hpp or <GameName>Set.hpp, both
    of those are already included by default.

"refresh" node
   <refresh>
   </refresh>

   Attributes: none
   Child Nodes: none
   
   this tag is used as the body of a method with signature:
   void SendFullState(const std::string &i_PlayerName,const StateName &i_StateName);

   the code in this function should unicast to the given player (regardless of whether
   or not the player is actually playing in the game) the totality of the game state
   that that player is allowed to see given the given state name.

"transition" node
  <transition>
  </transition>

  Attributes:
	Required: name="name" -- name of transition must follow valid C++ type name syntax,
		  and furthermore, will be actuated by an incoming action message with
                  the same name (i.e. Transition 'DOMOVE' is activated by an incoming
                  action with name 'DOMOVE')

	Child Nodes:
	      action
		-- a given incoming action message will contain a specific and fixed
		   number of arguments, each one represnted by a 'var' node within
		   the action node, with the i'th argument of the message processed
		   by the i'th 'var' node of the action node.  a missing action node
		   indicates that this particlar action message has no arguments.
		   
		child node: 
		   var
		      attributes:
			required: name -- the C++ local variable name given to this argument
			optional: type -- the C++ type given to the local variable (defaults to 'int')
			optional: trans -- the C++ function that, given the incoming argument as as
				  string, turns it into the given type (defaults to
				  'boost::lexical_cast<type>' (must be a function that takes a
				  const std::string& and returns the specified type)
			optional: min -- smallest value allowed for the variable.  Will only 
				  correctly compile if the given type has a '<' operator defined.
				  min may be any arbitrary snippet of code that returns the same
				  type as the type of this var.
			optional: max -- largest value allowed for the variable.  Will only
				  correctly compile if the given type has a '>' operator defined.
				  max may be any arbitrary snippet of code that returns the
				  same type as the type of this var.
			optional: list -- contains a snippet of code that returns a
				  std::set<type>, and requires the incoming var to be one
				  of the items in the set.


	      allowed 
		no attributes, no children
		-- the contents of this node is a boolean expression returned by a method with signature:
		bool <TransitionName>_IsLegal(const std::string &i_PlayerName,const StateName &i_StateName)
		
		which should return true if and only if the given player is allowed to
		make this transition from the given state at this current point in the game.
		The framework validates that the given state is one of the 
		'from' states for this transition (see below), so the code snippet here
		does not need to do so, but can use the from state for other purposes if desired.
		
		If not present, the transition will automatically be allowed under all circumstances
		Note: the body of this code will will be printed between the C++ keyword 'return' 
		and before a ';'.

	      auto
	        no attributes, no children
		-- the contents of this node is a boolean expression returned by a method with signature
		bool <TransitionName>_IsAuto(const StateName &i_StateName)

		which should return true if and only if the game should automatically make
		this transition occur without user input.  
		The framework validates that the given state is one of the 
		'from' states for this transition (see below), so the code snippet here
		does not need to do so, but can use the from state for other purposes if desired.

		If not present, the game will under no circumstances automatically make this transition.
		Note: the body of this code will will be printed between the C++ keyword 'return' 
		and before a ';'.

	      body
		no attributes, no children
		-- the contents of this node is a snippet of C++ code that represents the body of
		a method with signature:
		bool <TransitionName>_ExecuteAction(const std::string &i_PlayerName,
						    const ActionParser &i_ap,
						    const StateName &i_StateName)

		the framework will automatically validate that i_StateName is one of the
		valid from states for this transition, and will also validate that the
		incoming action parser contains the correct number of arguments as given
		in the 'action' XML node, described above, and will furthermore create
		and validate the local variables as per the 'var' nodes.

		The return value specifies whether to actually make the transition
		from the from state to the to state.  As a general guideline, the
		code snippet should not modify the state of the game if it returns false.

	      transit
	        required attributes: from,to
		-- this node indicates that this transition is from the given
		   'from' state to the given 'to' state. 
	      cyclic
		required attribute: state
		no child nodes
		-- this node indicates that this transition is between the given
		   state and itself (i.e., is syntactic sugar for 
		   <transit from="STATE" to="STATE" />)

	      a given transition can have an arbitrary (non-zero) number
	      of transit and cyclic nodes, each representing the use of this
	      particular transition in the finite state machine (i.e. the same
	      'transition' can be used multiple times, use the i_StateName argument
	      to distinguish if that is signficant)  The only limitations are:
	      the same transition cannot be applied to the same 'from' state more
	      than once, and no transitions can leave the TerminalState state.

"event" node:
	Each event node is translated into a set of methods that allow the coder to
	send messages of a particular type to the players' clients.  A message, at the
	lowest level, is a carriage return terminated and comma delimited string with
	at least one field.  The first field is always the event name, and is used
	to distinguish messages from each other.  All other fields are 'arguments'
	to the message, representing any arbitrary information the coder wishes
	to send to the clients.  At the lowest level, fields cannot contain either
	commas or carriage returns, but the coder does not have to worry about
	these at the XML coding level; all strings are automatically encoded
	to remove commas and carriage returns.

	The DLL -> Server interface defines three different kinds of message
	send methods, which the 'event' handling logic builds on top of:
	* BroadCast -- this message is automatically sent to every person
		    in the room, regardless of whether or not they are a 
		    player in the game. (The game DLL itself is responsible for
		    knowing which people are playing in the game)  A BroadCast
		    should be used for transmitting completely public information 
		    about the game that observers and participants alike would
		    be able to see.  Your game logic is not informed when
		    people, whether observers or participants, enter or leave the
		    room, so it is important that publicly available information
		    be sent via this conduit.

	* UniCast -- this message is sent to a particular person, as long as
		  they are logged in and present in the room (there is no
		  harm at all in UniCasting to the appropriate person without
		  checking if they are present; as long as the 'refresh'
		  logic is written correctly, the game will take care of 
		  bringing the player back up to date when they return to the
		  room if they have left for any reason)  This kind of casting
		  is used for private information, like privately held hands of 
		  cards or non-public monies, that should only be known by one
		  particular player.

	* VariCast -- this message type is given an an object implementing the following
		   interface:

		   class NameBoolean
		   {
		   public:
			virtual bool operator(){const std::string &i_PlayerName) const;
		   };

		   and the system will send a message to every player in the room for
		   which the NameBoolean returns true when given the name.  This can,
		   in theory, be used to get a list of all the people in the room,
		   whether or not they are playing, but we would not recommend it;
		   there is no way for your code to tell if that list is still up
		   to date the next time it gets called.  This mechanism should be
		   used as a form of syntatic sugar on top of UniCast, if you have
		   some private information shared between multiple players in the
		   game and would like to inform only them of some information.

	<event></event>

	Attributes:
		Required: name -- represents the event (message) name
		Optional: type -- if not specified, type is 'manual', otherwise
			  coder can specify 'global' or 'private' (see details below)
		Special: toname -- code snippet to retrieve the name to send the
			 private request to.  Required for 'private' type, not
			 allowed for other types.

	Child Nodes:
	      var
		attributes: 
			    required: name -- name of argument to event (documentation
				      only if var has a 'source')
			    required: type -- C++ type of argument
			    special: source -- code snippet to retrieve the value of this
				     argument.  not a valid attribute if event type is
				     'manual', required argument if event type is 
				     'global' or 'private'
	     iterator
		attributes:
			    required: name -- name of iteration variable
			    required: type -- C++ type of iteration variable
			    required: start -- C++ snippet for initial value
			    required: stop -- C++ snippet for terminal value
			    an iter generates a C++ construct thus:
			    
				for (<type> <name> = <start> ; <name> != <stop> ; ++<name>)
			    
			    and can be used to reduce the visual complexity of your 
			    code snippets, see below for details.

	Details:

	* 'manual' mode.  This is the simplest form of event,
	designated by a lack of 'type' attribute.  For this event,
	'toname', 'source', and 'iter' XML nodes/attributes are not
	allowed.  Three methods are created when this kind of event is specified, each
	with an argument for each 'var' specified, thus:
	
	<event name="MOVE">
	       <var name="movingPlayerId" type="int" />
	       <var name="fromSpace" type="std::string" />
	       <var name="toSpace" type="std::string" />
	</event>

	creates the following methods:
	void UnicastMOVE(const std::string &i_PlayerName,const int &movingPlayerId,
			 const std::string &fromSpace,const std::string &toSpace) const;

	void VaricastMOVE(const NameBoolean &i_Variator,const int &movingPlayerId,
			  const std::string &fromSpace,const std::string &toSpace) const;

	void BroadcastMOVE(const NameBoolean &i_Variator,const int &movingPlayerId,
			   const std::string &fromSpace,const std::string &toSpace) const;

	* 'global' mode.  This mode requires that every 'var' have a 'source' attribute
	set, which represents a snippet of code that presents the same type as the
	one specified for the var (or one that is automatically cast to that type, i.e.
	if the type is specified as 'int', the snippet can return a char or a short)
	This will significantly reduce the visual complexity of your code.  example:

	(in GameState.hpp)
	
		int GetGameLength() const;
		bool UseAdvancedRules() const;

	<event name="OPTIONS" type="global">
	       <var name="gameLength" type="int" source="GetGameLength()" />
	       <var name="useAdvancedRules" type="bool" source="UseAdvancedRules()" />
	</event>

	creates the following methods:

	void UnicastOPTIONS(const std::string &i_PlayerName);
	void VaricastOPTIONS(const NameBoolean &i_Variator);
	void BroadcastOPTIONS();

	all three methods will send the value returned by GetGameLength() as their
	first message argument, and the value returned by UseAdvancedRule() as their
	second message argument.

	A very common need is for a message to be sent for a series of things at
	one time.  the <iterator> construct allows for this.  For example, 
	
	<event name="PLAYERITEMS" type="global">
	       <iterator name="playerindex" type="size_t" start="0" stop="GetPlayers().size()"/>
		<iterator name="itemindex" type="size_t" start="0" stop="GetPlayers()[playerindex].GetOwnedItems().GetItemList().size()"/>
		<var name="i_playerid" type="size_t" source="playerindex"/>
		<var name="i_itemindex" type="size_t" source="itemindex"/>
		<var name="i_itemid" type="int" source="GetPlayers()[playerindex].GetOwnedItems().GetItemList()[itemindex]" />
	</event>

	creates the following series of methods:
	
	// these three methods send all items owned by all players to
	// one player, a set of players, and all players respectively.
	void UnicastPLAYERITEMS(const std::string &i_PlayerName) const;
	void VaricastPLAYERITEMS(const NameBoolean &i_Variator) const;
	void BroadcastPLAYERITEMS() const;

	// these three methods send all items owned by one player (the one with the given index)
	// to one player, a set of players, and all players, respectively.
	void UnicastUpdatePLAYERITEMSByplayerindex(const std::string &i_PlayerName,const size_t &playerindex) const;
	void VaricastUpdatePLAYERITEMSByplayerindex(const NameBoolean &i_Variator,const size_t &playerindex) const;
	void BroadcastUpdatePLAYERITEMSByplayerindex(const size_t &playerindex) const;

	// these three methods allow the coder to choose to send the item at a particular index for a particular player to
	// one player, a set of players, or all players, respectively.
	void UnicastUpdatePLAYERITEMSByplayerindexAndByitemindex(const std::string &i_PlayerName,const size_t &playerindex,const size_t& itemindex) const;
	void VaricastUpdatePLAYERITEMSByplayerindexAndByitemindex(const NameBoolean &i_Variator,const size_t &playerindex,const size_t& itemindex) const;
	void BroadcastUpdatePLAYERITEMSByplayerindexAndByitemindex(const size_t &playerindex,const size_t& itemindex) const;
	
	* 'private' mode -- this mode is currently in beta, but is designed to allow the sending of a particular message to
	  only one individual, and by extension, a unique private message.  Currently, the only allowed iterator is
	  one over a set of players, which is used in the 'AllCast'.

	  <event name="PLAYERCARDS" type="private" toname="GetPlayers()[playerindex].GetName()">
		 <iterator name="playerindex" type="size_t" start="0" stop="GetPlayers().size()"/>
		 <var name="i_cardstring" type="std::string" source="GetPlayers()[playerindex].GetCommodityHand()" />
	  </event>

	  creates the following two methods:
	  
	  // sends the player cards string for a given player (by index) to that player)
	  void SingleCastPLAYERCARDS(const size_t &playerindex) const;
	  // sends each player their own player cards string.
	  void AllCastPLAYERCARDS() const;

	  Note:  private mode has a very primitive feature set (currently there is no way to send a set of
	  messages to a given player or each player), and the interface may change over time.


TBD:  Compiling the code

